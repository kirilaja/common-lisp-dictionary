;atom
(defun consp (x) (not (atom x)))

;eq
(defun null (x) (eq x '()))

;car
(defun first (x) (car x))
(defun caar (x) (car (car x)))   

;cdr
(defun rest (x) (cdr x))

;cons
(defun acons (key val alist) (cons (cons key val) alist))

;atom eq 
(defun listp (x) (or (consp x) (null x)))

;atom car
;atom cdr
;atom cons
;eq car

;eq cdr
(defun nthcdr (x y) (if (null y) nil (if (= x 0) y (nthcdr (- x 1) (cdr y)))))
(defun length (x) (if (null x) 0 (1+ (length (cdr x)))))
(defun last (x) (if (= (length x) 1) x (last (cdr x))))

;eq cons
(defun make-list (i s) (if (zerop i) nil (cons s (make-list (- i 1) s))))

;car cdr
;car cons
;cdr cons
;atom eq car
;atom eq cdr
;atom eq cons
;atom car cdr
;atom car cons
;atom cdr cons

;eq car cdr
(defun nth (x y) (if (null y) nil (if (= x 0) (car y) (nth (- x 1) (cdr y))))) 
(defun member (x y) (if (null y) nil (if (eq x (car y)) y (member x (cdr y)))))   

;eq car cons
;eq cdr cons
;car cdr cons
;atom eq car cdr
(defun assoc (x a) (if (equal (caar a) x) (car a) (assoc x (cdr a)))) ; LISP 1.5

;eq car cdr cons
(defun append (x y) (if (null x) y (cons (car x) (append (cdr x) y))))
(defun union (x y) (if (null x) y (if (member (car x) y) (union (cdr x) y) (if t (cons (car x) (union (cdr x) y))))))
(defun intersection (x y) (if (null x) nil (if (member (car x) y) (cons (car x) (intersection (cdr x) y)) (if t (intersection (cdr x) y))))) 

;car cdr cons atom
(defun copy-list (x) (if (atom x) x (cons (car x) (copy-list (cdr x)))))
(defun copy-tree (x) (if (atom x) x (cons (copy-tree (car x)) (copy-tree (cdr x)))))

;cdr cons atom eq
;cons atom eq car
;atom eq car cdr cons
 
;math
(defun abs (x) (if (> x 0) x (- 0 x)))
(defun plusp (x) (if (> x 0) t))
(defun minusp (x) (if (< x 0) t))
(defun >= (x y) (or (> x y) (= x y)))
(defun <= (x y) (or (< x y) (= x y)))
(defun /= (x y) (or (< x y) (> x y)))

;lambda
(defun or (a b) (if a t (if t b)))
(defun not (x) (if x nil t))

;logic
(defun and (a b) (not (or (not a) (not b))))                           
(defun a-b (a b) (not (or (not a) b)))
(defun b-a (a b) (not (or (not b) a)))
(defun xor (a b) (or (not (or (not a) b)) (not (or (not b) a))))
(defun nor (a b) (not (or a b)))
(defun a==b (a b) (not (or (not (or (not a) b)) (not (or (not b) a)))))
(defun b->a (a b) (or (not b) a))
(defun a->b (a b) (or (not a) b))
(defun nand (a b) (not (and a b)))

;set
(defun rplaca (x y) (setf (car x) y))
(defun rplacd (x y) (setf (cdr x) y))
(defun pop (y) (let ((x (car y))) (setf y (cdr y)) x))
