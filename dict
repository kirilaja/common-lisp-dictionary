;atom
(defun consp (x) (not (atom x)))

;eq
(defun null (x) (eq x '()))

;car
(defun first (x) (car x))
(defun caar (x) (car (car x)))   

;cdr
(defun rest (x) (cdr x))

;cons
(defun acons (key val alist) (cons (cons key val) alist))

;atom equal 
(defun listp (x) (or (consp x) (null x)))

;equal rest
(defun nthcdr (x y) (if (null y) nil (if (= x 0) y (nthcdr (- x 1) (cdr y)))))
(defun length (x) (if (null x) 0 (1+ (length (cdr x)))))
(defun last (x) (if (= (length x) 1) x (last (cdr x))))

;equal cons
(defun make-list (i s) (if (zerop i) nil (cons s (make-list (- i 1) s))))

;equal first rest
(defun nth (x y) (if (null y) nil (if (= x 0) (car y) (nth (- x 1) (cdr y))))) 
(defun member (x y) (if (null y) nil (if (eq x (car y)) y (member x (cdr y)))))   

;atom equal first rest
(defun assoc (x a) (if (null a) nil (if (equal (caar a) x) (car a) (assoc x (cdr a))))) 

;equal first rest cons
(defun append (x y) (if (null x) y (cons (car x) (append (cdr x) y))))
(defun reverse (lst) (if (null lst) nil (append (reverse (rest lst)) (cons (first lst) '() )))) 
(defun union (x y) (if (null x) y (if (member (car x) y) (union (cdr x) y) (if t (cons (car x) (union (cdr x) y))))))
(defun intersection (x y) (if (null x) nil (if (member (car x) y) (cons (car x) (intersection (cdr x) y)) (if t (intersection (cdr x) y))))) 
(defun set-difference (x y) (if (null x) nil (if (not (member (first x) y)) (cons (first x) (set-difference (rest x) y)) (set-difference (rest x) y)))) ; Common Lisp

;first rest cons atom
(defun copy-list (x) (if (atom x) x (cons (car x) (copy-list (cdr x)))))
(defun copy-tree (x) (if (atom x) x (cons (copy-tree (car x)) (copy-tree (cdr x)))))

;math
(defun abs (x) (if (> x 0) x (- 0 x)))
(defun plusp (x) (if (> x 0) t))
(defun minusp (x) (if (< x 0) t))
(defun >= (x y) (or (> x y) (= x y)))
(defun <= (x y) (or (< x y) (= x y)))
(defun /= (x y) (or (< x y) (> x y)))

;lambda
(defun or (a b) (if a t (if t b)))
(defun not (x) (if x nil t))

;logic
(defun and (a b) (not (or (not a) (not b))))                           
(defun a-b (a b) (not (or (not a) b)))
(defun b-a (a b) (not (or (not b) a)))
(defun xor (a b) (or (not (or (not a) b)) (not (or (not b) a))))
(defun nor (a b) (not (or a b)))
(defun a==b (a b) (not (or (not (or (not a) b)) (not (or (not b) a)))))
(defun b->a (a b) (or (not b) a))
(defun a->b (a b) (or (not a) b))
(defun nand (a b) (not (and a b)))

;set
(defun rplaca (x y) (setf (car x) y))
(defun rplacd (x y) (setf (cdr x) y))
(defun pop (y) (let ((x (car y))) (setf y (cdr y)) x))
