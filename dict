;atom
(defun consp (x) (not (atom x)))

;eq
(defun null (x) (eq x '()))

;car
(defun first (x) (car x))
(defun caar (x) (car (car x)))   

;cdr
(defun rest (x) (cdr x))

;cons
(defun acons (key val alist) (cons (cons key val) alist))

;atom equal 
(defun listp (x) (or (consp x) (null x)))

;equal rest
(defun nthcdr (x y) (if (null y) nil (if (= x 0) y (nthcdr (- x 1) (rest y)))))
(defun length (x) (if (null x) 0 (1+ (length (rest x)))))
(defun last (x) (if (= (length x) 1) x (last (rest x))))

;equal cons
(defun make-list (i s) (if (zerop i) nil (cons s (make-list (- i 1) s))))

;first rest
(defun cdar (x) (cdr (car x)))

;equal first rest
(defun nth (x y) (if (null y) nil (if (= x 0) (first y) (nth (- x 1) (rest y))))) 
(defun member (x y) (if (null y) nil (if (eq x (first y)) y (member x (rest y)))))   

;atom equal first rest
(defun equal (x y) (if (or (and (atom x) (atom y) (eq x y)) (and (not (atom x)) (not (atom y)) (equal (first x) (first y)) (equal (rest x) (rest y)))) t))
(defun assoc (x a) (if (null a) nil (if (equal (caar a) x) (first a) (assoc x (rest a))))) 
(defun rassoc (x a) (if (null a) nil (if (equal (cdar a) x) (first a) (rassoc x (rest a)))))

;equal first rest cons
(defun append (x y) (if (null x) y (cons (first x) (append (rest x) y))))
(defun reverse (lst) (if (null lst) nil (append (reverse (rest lst)) (cons (first lst) '() )))) 
(defun union (x y) (if (null x) y (if (member (first x) y) (union (rest x) y) (if t (cons (first x) (union (rest x) y))))))
(defun intersection (x y) (if (null x) nil (if (member (first x) y) (cons (first x) (intersection (rest x) y)) (if t (intersection (rest x) y))))) 
(defun set-difference (x y) (if (null x) nil (if (not (member (first x) y)) (cons (first x) (set-difference (rest x) y)) (set-difference (rest x) y)))) ; Common Lisp

;first rest cons atom
(defun copy-list (x) (if (atom x) x (cons (first x) (copy-list (rest x)))))
(defun copy-tree (x) (if (atom x) x (cons (copy-tree (first x)) (copy-tree (rest x)))))

;atom equal first rest cons
(defun remove (obj lst) (if (null lst) nil (if (equal obj (first lst)) (remove obj (rest lst)) (cons (first lst) (remove obj (rest lst))))))
(defun subst (new old tree) (if (equal tree old) new (if (atom tree) tree (cons (subst new old (first tree)) (subst new old (rest tree)))))) ; does not work for dotted lists

;math
(defun abs (x) (if (> x 0) x (- 0 x)))
(defun plusp (x) (if (> x 0) t))
(defun minusp (x) (if (< x 0) t))
(defun >= (x y) (or (> x y) (= x y)))
(defun <= (x y) (or (< x y) (= x y)))
(defun /= (x y) (or (< x y) (> x y)))

;lambda
(defun or (a b) (if a t (if t b)))
(defun not (x) (if x nil t))

;logic
(defun and (a b) (not (or (not a) (not b))))                           
(defun a-b (a b) (not (or (not a) b)))
(defun b-a (a b) (not (or (not b) a)))
(defun xor (a b) (or (not (or (not a) b)) (not (or (not b) a))))
(defun nor (a b) (not (or a b)))
(defun a==b (a b) (not (or (not (or (not a) b)) (not (or (not b) a)))))
(defun b->a (a b) (or (not b) a))
(defun a->b (a b) (or (not a) b))
(defun nand (a b) (not (and a b)))

;set
(defun rplaca (x y) (setf (car x) y))
(defun rplacd (x y) (setf (cdr x) y))
(defun pop (y) (let ((x (first y))) (setf y (rest y)) x))
